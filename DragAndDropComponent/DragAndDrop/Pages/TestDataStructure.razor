@page "/test-datastruc"
@using DragAndDrop.Components
@using DragAndDrop.Components.Interfaces
@using System.Globalization

<h3>Test Data Structure</h3>
@if (container is null) {
  <p>There is no drag and drop container structure</p>
} else {
  <div class="draganddrop-container" ondragover="event.preventDefault();">
    <h3>@container.Name</h3>
    @for (var i = 0; i < container.Children.Count(); i++) {
      var group = container.Children[i] as DraggableGroupViewModel;
      <div class="draganddrop-group"
           draggable="@(group.DragEnabled.ToString().ToLower(CultureInfo.CurrentCulture))"
           ondragover="event.preventDefault();"
           @ondragstart="@((e) => HandleDragStart(e, group))"
           @ondragend="HandleDragEnd"
           @ondrop="@((e) => HandleDrop(e, group, group.Children.Count()))"
           @ondrop:preventDefault="true">
        <div class="draganddrop-groupname">
          @*
            Note: The current Group's order is based on its index within the parent container:
              group.Parent.Children.IndexOf(group)
          *@
          @group.Name
        </div>
        <div class="draganddrop-item-list">
          @for (var j = 0; j < group.Children.Count(); j++) {
            var item = (DraggableItemViewModel<string>)group.Children[j];
            var curItemIndex = item.Parent.Children.IndexOf(item);
            <div class="draganddrop-item"
                 draggable="@(item.DragEnabled.ToString().ToLower(CultureInfo.CurrentCulture))"
                 data-value="@item"
                 @ondragstart="@((e) => HandleDragStart(e, item))"
                 @ondragstart:stopPropagation="true"
                 @ondragend="HandleDragEnd"
                 @ondragend:stopPropagation="true"
                 ondrop="event.preventDefault();">
              <div class="draganddrop-itemcontent"
                   @ondrop="@((e) => HandleDrop(e, group, curItemIndex))"
                   @ondrop:stopPropagation="true"
                   style="height:1em; overflow-y:visible;">
                @*
                  Note: The current Item's order is based on its index within the parent container:
                    item.Parent.Children.IndexOf(item)
                *@
                @item.Item
              </div>
              <div class="draganddrop-dropafter"
                   @ondrop="@((e) => HandleDrop(e, group, curItemIndex + 1))"
                   @ondrop:stopPropagation="true"
                   style="height:.4em;background-color:magenta;"></div>
            </div>
          }
        </div>
      </div>
    }
  </div>
}

@code {
  DragAndDropContainerViewModel container;
  bool dragging;
  IDraggableElement curDraggedElement;

  protected override void OnInitialized() {
    container = new DragAndDropContainerViewModel() {
      Name = "Top-most container element",
      Children = new List<IDragAndDropElement>()
    };

    // Create 4 sample groups with 6 items each
    var intList = new List<int>() { 1, 2, 3, 4 };
    for (var i = 0; i < 4; i++) {
      var group = new DraggableGroupViewModel() {
        Name = $"Group {i + 1}",
        AllowedTargetNames = intList.Where(il => il != i).Select(il => $"Group {il + 1}").ToList(),
        Parent = container,
        Children = new List<IDragAndDropElement>()
      };
      for (var j = 0; j < 5; j++) {
        var item = new DraggableItemViewModel<string>() {
          Item = $"Group {i + 1}, Item {j + 1}",
          Name = $"Group {i + 1}, Item {j + 1}",
          Parent = group,
          AllowedTargetNames = new List<string>() { "Group 1", "Group 2", "Group 3", "Group 4" }
        };
        group.Children.Add(item);
      }
      container.Children.Add(group);
    }

    var item1 = new DraggableItemViewModel<string>() {
      Name = "MyName",
      AllowedTargetNames = new List<string>() { "Group 1" },
      DragEnabled = true,
      Parent = (DraggableGroupViewModel)container.Children[0],
      Item = "Part of new group"
    };

    ((DraggableGroupViewModel)container.Children[0]).Children.Add(item1);

    var item2 = new DraggableItemViewModel<string>() {
      Name = "OtherName",
      AllowedTargetNames = new List<string>() { "Group 2" },
      DragEnabled = true,
      Parent = (DraggableGroupViewModel)container.Children[1],
      Item = "Other part of new group"
    };

    ((DraggableGroupViewModel)container.Children[1]).Children.Add(item2);

    var item3 = new DragAndDropItemViewModel<string>() {
      Name = "ImmovableDnDItem",
      Parent = container,
      Item = "You cannot move me"
    };

    container.Children.Insert(0, item3);

    var newGroup = ((IDragAndDropElement)item1).GroupWith(item2, true, false);
    // Truths about parents
    var thisIsTrue = (newGroup.Parent == container.Children[1]);
    thisIsTrue = (item1.Parent == newGroup);
    thisIsTrue = (item2.Parent == newGroup);

    // Truths about children
    thisIsTrue = (newGroup.Children.Count == 2);
    thisIsTrue = (newGroup.Children.Contains(item1));
    thisIsTrue = (newGroup.Children.Contains(item2));

    // Truths about names
    var compositeName = $"{item1.Name}_{item2.Name} Group";
    thisIsTrue = (newGroup.Name == compositeName);
    thisIsTrue = (item1.AllowedTargetNames.Contains(compositeName));
    thisIsTrue = (item2.AllowedTargetNames.Contains(compositeName));

    // Truths about order
    var otherNewGroup = newGroup.GroupWith<DraggableGroupViewModel>(item3, true);
    thisIsTrue = (otherNewGroup.Parent == container);
    thisIsTrue = (newGroup.Parent == otherNewGroup);
    thisIsTrue = (item3.Parent == otherNewGroup);

    compositeName = $"{item3.Name}_{newGroup.Name} Group";
    // (ImmovableDnDItem_(MyName_OtherName Group))

    thisIsTrue = (otherNewGroup.Children.Count == 2);


  }

  void HandleDragStart(DragEventArgs e, IDraggableElement element) {
    curDraggedElement = element;
    dragging = true;
  }

  void HandleDragEnd(DragEventArgs e) {
    dragging = false;
    curDraggedElement = null;
  }

  void HandleDrop(DragEventArgs e, IDragAndDropContainer target, int targetIndex) {
    if (curDraggedElement is null) { return; }

    var movingWithinGroup = curDraggedElement.Parent.Name == target.Name;
    var originalIndex = curDraggedElement.Parent.Children.IndexOf(curDraggedElement);

    if ((movingWithinGroup && originalIndex == targetIndex) || !curDraggedElement.CanDrop(target)) { return; }

    if (target.Children == null) { target.Children = new List<IDragAndDropElement>(); }
    // In all cases, insert the dragged element into the list of children of the target element
    target.Children.Insert(targetIndex, curDraggedElement);

    if (movingWithinGroup) {
      // If moving within the same group (re-ordering only), remove
      // the original element from the group.  When doing so, add 1
      // to the index to remove from if the original element is
      // moving from a higher numbered index to a lower numbered index
      target.Children.RemoveAt(originalIndex + (originalIndex > targetIndex ? 1 : 0));
    } else {
      // If moving to a different group, remove the original element
      // from its current Parent's Children, and reparent to the new
      // group
      curDraggedElement.Parent.Children.RemoveAt(originalIndex);
      curDraggedElement.Parent = target;
    }
  }
}
