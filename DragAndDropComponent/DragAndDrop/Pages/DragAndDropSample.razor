@page "/dnd"
@using DragAndDrop.Data

<h3>Drag And Drop Introduction</h3>

<input type="checkbox" id="more-less-check" @bind="@less" />
<div class="intro-section">
  <div class="fading-tail"></div>
  <div class="clearfix"></div>
  <div class="text-muted collapser-text"><label for="more-less-check"><em>@(less ? "more" : "less")</em></label></div>
  <p>
    This drag and drop sample shows the desired behavior of a reusable drag and drop component. The functionality
    to be implemented should allow users to:
  </p>
  <ul>
    <li>Drag items within a group to reorder.</li>
    <li>Drag items between groups to move from one group to another in the desired location.</li>
    <li>Drag items onto group headers to add to the end of that group.</li>
  </ul>
  <p>
    My goal is to turn this sample into a reusable component that has a good base (default) styling and functionality,
    as well as one that allows for full customization.  I want to give the developer the freedom to:
  </p>
  <ul>
    <li>style the container for the 0 or more groups of draggable items</li>
    <li>style the groups or draggable items</li>
    <li>whether or not to show the group headers</li>
    <li>style the draggable items</li>
    <li>style the drop before, on, and after</li>
    <li>decide where the user is allowed to drag from/drop to</li>
    <li>allow any object collection to display as the items</li>
    <li>and hopefully more</li>
  </ul>
  <p class="text-light bg-dark p-2" style="border-radius:.4em">
    <strong>NOTE:</strong> Currently, I am using JavaScript to listen for changes to the DOMTree since some browsers
    requires the <code>ondragstart</code> event to perform <code>event.dataTransfer.setData(...)</code>.  I chose to
    use a js file instead of using JS Interop since I have not dove into using JS Interop yet.  I am also hoping to
    find a way to make the js file only download for browsers that require it.
  </p>
  <p>
    Below, I am starting with bare minimum styling (only class names are used, but no styling applied).  I want to
    get the functionality working first. The goal is to create a version that moves the item as it is dragged up or
    down.
  </p>
</div>

@* The Drag And Drop Sample *@
<h3>Drag And Drop Sample</h3>

<div class="draganddrop-container">
  @if (draggableItems is null || draggableItems.Count() == 0) {
    <p>TODO: Display empty list</p>
  } else {
    foreach (var curDNDGroup in draggableItems.Select(x => x.GroupName).Distinct().OrderBy(groupName => groupName)) {
      <div class="draganddrop-group"
           ondragover="event.preventDefault();"
           @ondrop="@((e) => HandleDrop(e, curDNDGroup, draggableItems.Count(d => d.GroupName == curDNDGroup)))">
        <h3>@curDNDGroup</h3>
        <ul class="draganddrop-item-list" style="list-style: none;">
          @foreach (var curDNDItem in draggableItems.Where(x => x.GroupName == curDNDGroup).OrderBy(x => x.Order)) {
            <li class="draganddrop-item"
                draggable="true"
                @ondragstart="@((e) => HandleDragStart(e, curDNDItem))"
                @ondragend="HandleDragEnd">
              <div class="draganddrop-itemcontent"
                   @ondrop="@((e) => HandleDrop(e, curDNDGroup, curDNDItem.Order))"
                   @ondrop:stopPropagation="true"
                   @ondragover="(e) => HandleDrop(e, curDNDGroup, curDNDItem.Order)"
                   @ondragover:stopPropagation="true">
                @curDNDItem.Item
              </div>
              <div class="draganddrop-dropafter"
                   @ondrop="@((e) => HandleDrop(e, curDNDGroup, curDNDItem.Order + 1))"
                   @ondrop:stopPropagation="true"
                   @ondragover="(e) => HandleDrop(e, curDNDGroup, curDNDItem.Order + 1)"
                   @ondragover:stopPropagation="true" style="height:.2em"></div>
            </li>
          }
        </ul>
      </div>
    }
  }
</div>

@code {
  // UI Only - collapse and show more info
  bool less = true;

  /// <summary>The list of draggable items to be displayed</summary>
  /// <remarks>We are currently using strings as the item type, but this can be any object</remarks>
  List<DraggableItem<string>> draggableItems = new List<DraggableItem<string>>();

  /// <summary>The draggable item being dragged</summary>
  DraggableItem<string> curItem = null;
  /// <summary>Whether or not dragging is occurring</summary>
  bool dragging;

  protected override void OnInitialized() {
    // Initialize some items to display
    for (var i = 0; i < 3; i++) {
      for (var j = 0; j < 7; j++) {
        draggableItems.Add(new DraggableItem<string>() {
          GroupName = $"Group {i + 1}",
          Order = j,
          Item = $"Group {i + 1}, Item {j + 1}"
        });
      }
    }
  }

  void HandleDragStart(DragEventArgs e, DraggableItem<string> draggedItem) {
    curItem = draggedItem;
    dragging = true;
  }

  void HandleDragEnd(DragEventArgs e) {
    dragging = false;
  }

  async Task HandleDrop(DragEventArgs e, string newGroupName, int newOrder) {
    var dragItem = draggableItems.SingleOrDefault(d => d.Id == curItem.Id);
    if (dragItem is { }) {
      MoveItem(dragItem.GroupName, newGroupName, dragItem.Order, newOrder);
    }
    await InvokeAsync(() => StateHasChanged());
  }

  /// <summary>
  /// Handles moving a <see cref="DragAndDrop.Data.DraggableItem{T}"/>
  /// </summary>
  /// <param name="fromGroupName">
  /// The group name the <see cref="DragAndDrop.Data.DraggableItem{T}"/> is moving from
  /// </param>
  /// <param name="toGroupName">
  /// The group name the <see cref="DragAndDrop.Data.DraggableItem{T}"/> is moving to
  /// </param>
  /// <param name="fromOrder">
  /// The location number to move the <see cref="DragAndDrop.Data.DraggableItem{T}"/> from
  /// within the <paramref name="fromGroupName"/>
  /// </param>
  /// <param name="toOrder">
  /// The location number to move the <see cref="DragAndDrop.Data.DraggableItem{T}"/> to
  /// within the <paramref name="toGroupName"/>
  /// </param>
  private void MoveItem(string fromGroupName, string toGroupName, int fromOrder, int toOrder) {
    var sameGroupName = fromGroupName == toGroupName;
    if (sameGroupName && fromOrder == toOrder) { return; }

    var dragItem = draggableItems.SingleOrDefault(d => d.Id == curItem.Id);
    if (sameGroupName) {
      // If moving within the same dropzone (re-ordering only)
      var items = draggableItems.Where(d => d.GroupName == fromGroupName);
      if (fromOrder < toOrder) {
        // When moving from a lower numbered position to a higher numbered position,
        // reduce the number of each item's position that is greater than the item's
        // current position, but less than or equal to the new position
        items.Where(d => d.Order > fromOrder && d.Order < toOrder).ToList().ForEach(d => {
          d.Order--;
        });
      } else {
        // When moving from a higher numbered position to a lower numbered position,
        // increase the number of each item's position that is less than the item's
        // current position, but greater than or equal to the new position
        items.Where(d => d.Order < fromOrder && d.Order >= toOrder).ToList().ForEach(d => {
          d.Order++;
        });
      }
    } else {
      // If moving from one group to another, decrease the position number for all
      // items in the source group whose position number is greater than the item's
      // current position
      draggableItems.Where(d => d.GroupName == fromGroupName && d.Order > fromOrder).ToList().ForEach(d => {
        d.Order--;
      });
      // Also, increase the position number for all items in the destination group
      // whose position number is greater than or equal to the position the item is being
      // dropped at
      draggableItems.Where(d => d.GroupName == fromGroupName && d.Order >= toOrder).ToList().ForEach(d => {
        d.Order++;
      });
    }

    // Set the group and order for the item being dragged
    dragItem.GroupName = toGroupName;
    dragItem.Order = toOrder;

    // Renumber the affected group item order to remove any gaps that may have been
    // caused by the move process
    RenumberList(fromGroupName);
    if (fromGroupName != toGroupName) {
      RenumberList(toGroupName);
    }
  }

  /// <summary>
  /// Renumbers the item order in the group with the specified name to remove gaps or
  /// duplicate numbers
  /// </summary>
  /// <param name="inGroupName"></param>
  private void RenumberList(string inGroupName) {
    var items = draggableItems.Where(d => d.GroupName == inGroupName).OrderBy(d => d.Order);
    for (var i = 0; i < items.Count(); i++) {
      items.ElementAt(i).Order = i;
    }
  }
}
